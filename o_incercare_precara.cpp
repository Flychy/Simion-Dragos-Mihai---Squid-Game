/**--------------------------Object Oriented Programming Project-----------------------**/
/*---------------------------------------2021-----------------------------------------*/

 /**------------------------------------SQUID GAME------------------------------------**/
 /* The project is meant to recreate the logical concepts of the South Korean serial called
 "Squid game".
    We have 108 players that are entering in the game each of them being divided into 2
 classes : The Competitors and The Supervisors.
    For each of them we know their full name, the city where they live, their debt to banks,
 and their weight.
    Every player has his specific number of playing , as well as the supervisors. More
than that the supervisors have a distinctive form on their masks.
    There are going to be a total of 99 competitors and 9 supervisors. The supervisors
are going to be divided into 3 separate teams for each form and each supervisor is going
to have under its supervision an equal number of players.
    There are going to be 4 games:
    1.)"Red Light Green Light" - Only the users with odd number of playing are going to
                                the next game
    2.)"Tug Of War" - The players are being divided randomly into 4 players teams and the
                    teams are going to fight two by two, the winning team being the team
                    with a higher weight
                    -Good to mention : if there are player that don't catch a team they
                    are going into the next round without having to play("the lucky ones")
    3.)"Marbles" - The remaining players are going to be divided in pairs of two, and fight
                each other using a random number generated by them. The smaller number
                wins.
    4.)"Genken" - Choosing the descending order of the competitors numbers, they are going
                to fight one by one playing rock paper scrissorss into a last man standing
                format till there is only one man standing
    The winner receives the sum of all the competitors debts
    Every supervisor receive the debt of every eliminated player that belongs to him, with
    the mention that the supervisor that has the winner competitor receive its debt multiplied
    by ten.
    At the final we are going to display the winner and the big prize, the list with the
    amount won by each supervisor, and the team with the most earnings.*/

 /*Before the coding part i would like to mention that the files with the competitors
 and the supervisors were created with the help of the script. I had 3 files with first names
 and last names and one with cities, and i've written to a file 108 random  first names,
 last names , cities from file, and generated random debts, and kilograms and a random number
 for each line. The file was splitted in two files with competitors and supervisors
 with 99 competitors and 9 supervisors, adding a form for each supervisor*/
 /*There was probably a way to do that within the C++ program, but i tried, it took me
 too much time, and i dont know if i could've done it without help, so i chose this
 path.*/
#include<iostream>
#include<fstream>
#include<vector>
#include <bits/stdc++.h>
#include<sstream>
#include<string.h>


using namespace std;

//A template used for sorting algorithms
//and to swap the wining players on the fourth game
template<class T>
void swapping(T &a, T &b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}

//The class of competitors with which we are going to read the informations
//from the participants
class Competitors
{

private:
    string number;
    string last_name;
    string first_name;
    string city;
    string debt;
    string kilos;

public:
    Competitors(string number, string last_name, string first_name, string city, string debt, string kilos);
    friend class TheFrontMan;


};

Competitors::Competitors(string number, string last_name, string first_name, string city, string debt, string kilos)
{
    this->number = number;
    this->last_name = last_name;
    this->first_name = first_name;
    this->city = city;
    this->debt = debt;
    this->kilos = kilos;
}

//The class of supervisors with which we are going to read the informations
//from the supervisors
class Supervisors
{
private:
    string form;
    string s_last_name;
    string s_first_name;
    string s_city;
    string s_debt;
    string s_kilos;
    string id_code;
public:
    Supervisors(string form, string s_last_name, string s_first_name, string s_city, string s_debt, string s_kilos, string id_code);
    friend class TheFrontMan;

};

Supervisors::Supervisors(string form, string s_last_name, string s_first_name, string s_city, string s_debt, string s_kilos, string id_code)
{
    this->form = form;
    this->s_last_name = s_last_name;
    this->s_first_name = s_first_name;
    this->s_city = s_city;
    this->s_debt = s_debt;
    this->s_kilos = s_kilos;
    this->id_code = id_code;
}

//The Front Man class, mainly created to handle all the organizational part, and the games
class TheFrontMan
{
private:
    vector<Competitors> list_of_competitors;
    vector<Supervisors> list_of_supervisors;
    vector<string> circles;
    vector<int> id_c;
    vector<int> id_t;
    vector<int> id_s;
    vector<int> tuggy;
    vector<int> round2;
    vector<int> round3;
    vector<string> triangles;
    vector<string> squares;
public:
    //a method meant to read and store all the informations about the competitors
    void comp_scheme()
    {
        string aux;
        string number, last_name, first_name, city, debt, kilos, err;
        //read from the competitors file
        try
        {
            ifstream MyCompetitors;
            MyCompetitors.open("users/competitors/competitors.csv");
            if(!MyCompetitors.is_open())
            {
                err = "\nThe file cannot be opened!\n";
                throw err;
            }
            while(getline(MyCompetitors, aux))
            {
                istringstream input(aux);
                getline(input, number, ',');
                getline(input, first_name, ',');
                getline(input, last_name, ',');
                getline(input, city, ',');
                getline(input, debt, ',');
                getline(input, kilos, ',');
                list_of_competitors.push_back(Competitors(number, first_name, last_name, city, debt, kilos));
            }
            MyCompetitors.close();
        }
        catch(string err)
        {
            cout << err;
            throw;
        }

        //there we are going to split each competitor to a random supervisor
        // mainly we put all the competitor numbers in a vector, we shuffle the vector
        //and we assign a supervisor in ascending order for each element from the shuffled
        //vector
        int i;
        int z;
        int a[100];

        vector<int> v1;

        for(z = 0; z < 99; ++z)
        {
            a[z] = z;
        }
        v1.assign(a, a + 99);

        int size = v1.size();

        for (i = 0; i < size - 1; ++i)
        {
            int j = i + rand() % (size - i);
            swap(v1[i], v1[j]);
        }
        //show(v1);
        ofstream MyRandomiser;
        MyRandomiser.open("users/teams/final_teams.csv");
        string line;
        superv_scheme();
        //after the suffle we assign and store a supervisor for each competitor
        //into a specific file
        for(i = 0; i < list_of_competitors.size(); ++i)
        {
            MyRandomiser << list_of_competitors[v1[i]].number << ","
            << list_of_competitors[v1[i]].debt << "," << list_of_supervisors[i].s_debt
            << "," <<list_of_supervisors[i].id_code << "\n" ;
        }
        MyRandomiser.close();

    }
    //a method meant to read and store all the informations about the supervisors
    void superv_scheme()
    {
        string aux;
        string form, s_last_name, s_first_name, s_city, s_debt, s_kilos, id_code, err;
        int i;

        try
        {
            ifstream MySupervisors;
            MySupervisors.open("users/supervisors/super.csv");
            if(!MySupervisors.is_open())
            {
                err = "\nThe file cannot be opened!\n";
                throw err;
            }
            while(getline(MySupervisors, aux))
            {
                istringstream input(aux);
                getline(input, form, ',');
                getline(input, s_first_name, ',');
                getline(input, s_last_name, ',');
                getline(input, s_city, ',');
                getline(input, s_debt, ',');
                getline(input, s_kilos, ',');
                getline(input, id_code, ',');
                list_of_supervisors.push_back(Supervisors(form, s_first_name, s_last_name, s_city, s_debt, s_kilos, id_code));
            }
            MySupervisors.close();
        }
        catch(string err)
        {
            cout << err;
            throw;
        }
        //As the rules says that we need to split the supervisors in 3 groups , and each
        //group has to have each form we separate the supervisors in 3 different files
        //for each form
        ofstream circleFile;
        circleFile.open("users/teams/circles.csv");

        ofstream triangleFile;
        triangleFile.open("users/teams/triangles.csv");

        ofstream squareFile;
        squareFile.open("users/teams/squares.csv");

        //There was a mistake at the creation of the file, i saw it too late and to
        //remediate the problem i had to modify the script with wich i've generated the
        //two starting files, so, to clarify:
        // "triunghi" = "triangle"
        // "cerc" = "circle"
        // "patrat" = "square"
        for(i = 0 ; i < 9 ; i++)
        {
            if(list_of_supervisors[i].form == "triunghi")
            {
                triangleFile << list_of_supervisors[i].id_code <<"\n";
            }
            if(list_of_supervisors[i].form == "cerc")
            {
                circleFile << list_of_supervisors[i].id_code << "\n";
            }
            if(list_of_supervisors[i].form == "patrat")
            {
                squareFile << list_of_supervisors[i].id_code << "\n";
            }
        }
    }
    //a function meant to help us to display the vector content
    void show(vector<int> const &input)
    {
        for (auto const& i: input)
        {
            std::cout << i << " ";
        }
    }
    //this method is created to separate each supervisor in a group
    //at the final we are going to have a file with the participating number(id_code)
    //of each supervisor, and an assigned team specificall string e.g. G1,G2,G3
    void team_tactic()
    {
        int C[3], T[10], S[10];
        string aux, err;
        int i;
        //We are going to read every form file that we've created and we are going
        //to give to each player a number from 1 to 3, so at the end we are going to
        //separated each number into their specifical group
        //e.g. the players that received the number 1 are going to be assigned with
        //the team 1 tag and so on for the next teams
        //read the circles file
        try
        {
            ifstream My_C_Team;
            My_C_Team.open("users/teams/circles.csv");
            if(!My_C_Team.is_open())
            {
                err = "\nThe file cannot be opened!\n";
                throw err;
            }
            while(getline(My_C_Team, aux))
            {
                istringstream input(aux);
                getline(input, aux, ',');
                id_c.push_back(stoi(aux));
                getline(input, aux);
                circles.push_back(aux);
            }
            My_C_Team.close();
        }
        catch(string err)
        {
            cout << err;
            throw;
        }
        for(i = 0; i < 3; i++)
        {
            id_c[i] >> C[i];
        }
        //read the triangles
        try
        {
            ifstream My_T_Team;
            My_T_Team.open("users/teams/triangles.csv");
            if(!My_T_Team.is_open())
            {
                err = "\nThe file cannot be opened!\n";
                throw err;
            }
            while(getline(My_T_Team, aux))
            {
                istringstream input(aux);
                getline(input, aux, ',');
                id_t.push_back(stoi(aux));
                getline(input, aux);
                triangles.push_back(aux);
            }
            My_T_Team.close();
        }

        catch(string err)
        {
            cout << err;
            throw;
        }
        for(i = 0; i < 3; i++)
        {
            id_t[i] >> T[i];
        }
        //read the squares
        try
        {
            ifstream My_S_Team;
            My_S_Team.open("users/teams/squares.csv");
            if(!My_S_Team.is_open())
            {
                err = "\nThe file cannot be opened!\n";
                throw err;
            }
            while(getline(My_S_Team, aux))
            {
                istringstream input(aux);
                getline(input, aux, ',');
                id_s.push_back(stoi(aux));
                getline(input, aux);
                squares.push_back(aux);
            }
            My_S_Team.close();
        }

        catch(string err)
        {
            cout << err;
            throw;
        }
        for(i = 0; i < 3; i++)
        {
            id_s[i] >> S[i];
        }

        //After the number generator step we assign a specificall tag for each player
        //considering its team and number match

        ofstream GroupOfTeams;
        GroupOfTeams.open("users/teams/teams.csv");
        for(i = 0; i < 3; i++)
        {
            if(id_t[i] < id_t[i+1] && id_t[i] < id_t[i+2])
            {
                GroupOfTeams << id_t[i] << "," <<  "G1\n";
            }
            else
            {
                if(id_t[i] > id_t[i-1] && id_t[i] < id_t[i+1])
                {
                    GroupOfTeams << id_t[i] << "," <<  "G2\n";
                }
                else
                {
                    if(id_t[i] > id_t[i-1] && id_t[i] > id_t[i-2])
                    {
                        GroupOfTeams << id_t[i] << "," <<  "G3\n";
                    }
                }
            }

        }

        for(i = 0; i < 3; i++)
        {
            if(id_c[i] < id_c[i+1] && id_c[i] < id_c[i+2])
            {
                GroupOfTeams << id_c[i] << "," <<  "G1\n";
            }
            else
            {
                if(id_c[i] > id_c[i-1] && id_c[i] < id_c[i+1])
                {
                    GroupOfTeams << id_c[i] << "," <<  "G2\n";
                }
                else
                {
                    if(id_c[i] > id_c[i-1] && id_c[i] > id_c[i-2])
                    {
                        GroupOfTeams << id_c[i] << "," <<  "G3\n";
                    }
                }
            }
        }
        for(i = 0; i < 3; i++)
        {
            if(id_s[i] < id_s[i+1] && id_s[i] < id_s[i+2])
            {
                GroupOfTeams << id_s[i] << "," <<  "G1\n";
            }
            else
            {
                if(id_s[i] > id_s[i-1] && id_s[i] < id_s[i+1])
                {
                    GroupOfTeams << id_s[i] << "," <<  "G2\n";
                }
                else
                {
                    if(id_s[i] > id_s[i-1] && id_s[i] > id_s[i-2])
                    {
                        GroupOfTeams << id_s[i] << "," <<  "G3\n";
                    }
                }
            }
        }
    }
    /*With that being said, let the games begin!*/
    /*The first game Green Light Red Light. There we convert the list of competitors
    number vector from a string to an int and after that we check for the odd numbers.
    If the competitor number is odd the respective player name is displayed on the screen
    and he is going into the next round
    No need there to create a file for those players as we know the number of players
    and the odd numbers.*/
    void red_light_green()
    {
        comp_scheme();
        int i;
        for(i = 0; i < list_of_competitors.size() ; i++)
        {
            stringstream geek(list_of_competitors[i].number);
            int x = 0;
            geek >> x;
            if(x % 2 != 0)
            {
                cout << "[" << list_of_competitors[i].number << "] "
                << list_of_competitors[i].last_name << " "
                << list_of_competitors[i].first_name << "\n";
            }
        }
        //unknown symbols in the compiler
        cout << "[" << list_of_competitors[0].number << "]"
        << list_of_competitors[0].last_name << " " << list_of_competitors[0].first_name;
    }
    /*  as from the previous game only the odd numbers remain ,I created an
    array only with the odd numbers from 1 to 99
    The game involves dividing the players into 4 equal teams at random in the concept
    I created. The first 4 players will be introduced in a team and the next 4 will be
    introduced in the next team and so on until an equal number of teams of 4 are created.
    The last 2 players remaining in the next round without having to fight.
    In order for this to be done randomly, we will put the array in a vector that we
    will mix, following that the players will be placed in a random order in the balance
    format explained above.
    We will put the number of players in the new order in a file, in order to have a
    good vision of the teams formed.
    Then comes the actual elimination algorithm in which the heavier team moves on,
    its members are passed to a usable file for the next game and also the players
    qualified for the Marbles game are displayed on the screen. .
    */
    void tug_of_war()
    {
        comp_scheme();
        //Array with the number of participants that are still in the game
        int a[50]= {1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,
                    51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99
                   };
        int i;
        int j;

        //Put those numbers in a vector and shuffle it
        vector<int> v1;
        v1.assign(a, a + 50);

        int size = v1.size();

        for (i = 0; i < size - 1; i++)
        {
            int j = i + rand() % (size - i);
            swap(v1[i], v1[j]);
        }

        string aux;
        string err;

        //store the random order in a file
        ofstream TugOfWar;
        TugOfWar.open("games/TufOfWar/tug.csv");
        for(i = 0; i < 50; i++)
        {
            TugOfWar << v1[i] << "\n" ;
        }
        TugOfWar.close();
        try
        {
            ifstream MyTug;
            MyTug.open("games/TufOfWar/tug.csv");
            if(!MyTug.is_open())
            {
                err = "\nThe file cannot be opened!\n";
                throw err;
            }
            while(getline(MyTug, aux))
            {
                istringstream input(aux);
                getline(input, aux, ',');
                tuggy.push_back(stoi(aux));

            }
            MyTug.close();
        }

        catch(string err)
        {
            cout << err;
            throw;
        }

        ofstream BattleWinners;
        BattleWinners.open("games/Marbles/winner.csv");

        //2 variables used to count the weight of the each team fighting each other
        int counter1 = 0;
        int counter2 = 0;
        //max value to be reached so the battles can end
        int value = 52;
        //the size of the teams
        int m = 4;
        //number of each player fighting
        int initial = 0;

        //fight till the number of teams is exhausted
        while(m != value)
        {

            for(i = initial; i < m; i++)
            {
                //conversion to int type
                stringstream geek(list_of_competitors[tuggy[i]-1].kilos);
                int x = 0;
                geek >> x;
                counter1 += x;
            }

            for(i = initial + 4; i < m + 4; i++)
            {
                stringstream geek(list_of_competitors[tuggy[i]-1].kilos);
                int x = 0;
                geek >> x;
                counter2 += x;
            }

            //put the winner teams in a new file
            if(counter1 > counter2)
            {
                for(i = initial ; i < m; i++)
                {
                    BattleWinners << tuggy[i] << "\n";
                }
            }
            if(counter2 > counter1)
            {
                for(i = initial + 4; i < m + 4; i++)
                {
                    BattleWinners << tuggy[i] << "\n";
                }
            }
            initial = initial + 8;
            m = m + 8;
            counter1 = 0;
            counter2 = 0;
        }

        //And the lucky ones
        for(i = 48; i < 50; i++)
        {
            BattleWinners << tuggy[i] << "\n";
        }
        BattleWinners.close();

        //Lets find out who is still in the game
        ifstream NextChap;
        NextChap.open("games/Marbles/winner.csv");
        try
        {
            ifstream NextChap;
            NextChap.open("games/Marbles/winner.csv");
            if(!NextChap.is_open())
            {
                err = "\nThe file cannot be opened!\n";
                throw err;
            }
            while(getline(NextChap, aux))
            {
                istringstream input(aux);
                getline(input, aux, ',');
                round2.push_back(stoi(aux));

            }
            NextChap.close();
        }

        catch(string err)
        {
            cout << err;
            throw;
        }
        cout << "\n\n";
        for(i = 0; i < round2.size(); i++)
        {
            cout << " " << list_of_competitors[round2[i]-1].number << " "
                 << list_of_competitors[round2[i]-1].last_name << " "
                 << list_of_competitors[round2[i]-1].first_name << "\n";
        }

    }

    /*for the Marbles game we take the qualified players from the previously
    created file and we will assign them a random number from 1 to 9999 so that
    there will be little chance that 2 numbers be repeated (this will be done with
    the help of vectors) then, depending on each number generated we will go through
    the algorithm of this game following that in a new file the qualified players in
    the grand final will be stored (these will also be displayed on the screen) */

    void marbles()
    {

        comp_scheme();
        int i;
        string aux, err;
        //vectors for the organizational part of the game: a vector for the player number
        //one for his random generated number, and finally the number of finalists
        vector<int> game_number;
        vector<int> player_number;
        vector<int> player_qualified;

        try
        {
            ifstream Players;
            Players.open("games/Marbles/winner.csv");
            if(!Players.is_open())
            {
                err = "\nThe file cannot be opened!\n";
                throw err;
            }
            while(getline(Players, aux))
            {
                istringstream input(aux);
                getline(input, aux, ',');
                round3.push_back(stoi(aux));
            }
            Players.close();
        }

        catch(string err)
        {
            cout << err;
            throw;
        }

        ofstream ReadyToPlay;
        ReadyToPlay.open("games/Marbles/ready.csv");

        for(i = 0; i < round3.size(); i++)
        {
            ReadyToPlay << round3[i] << "," << (rand() % 9999) << "\n";
        }
        ReadyToPlay.close();


        try
        {
            ifstream ReadyToPlay;
            ReadyToPlay.open("games/Marbles/ready.csv");
            if(!ReadyToPlay.is_open())
            {
                err = "\nThe file cannot be opened!\n";
                throw err;
            }
            while(getline(ReadyToPlay, aux))
            {
                istringstream input(aux);
                getline(input, aux, ',');
                player_number.push_back(stoi(aux));
                getline(input, aux);
                game_number.push_back(stoi(aux));
            }
            ReadyToPlay.close();
        }
        catch(string err)
        {
            cout << err;
            throw;
        }

        ofstream Qualified;
        Qualified.open("games/Marbles/qualified.csv");

        int j;
        int k = 0;
        int n = 1;

        //until the number of players reaches
        //the full number in the list, the players duel two by two
        while(n != 27)
        {
            for(j = k; j < n; j++)
            {
                if(game_number[j] > game_number[j + 1])
                {
                    Qualified << round3[j + 1] << "\n";
                }
                else
                {
                    if(game_number[j] < game_number[j + 1])
                    {
                        Qualified << round3[j] << "\n";
                    }
                }
                k = k + 2;
            }
            n = n + 1;
        }
        Qualified.close();

        //read the finalists from the file
        ifstream Qualification;
        Qualification.open("games/Marbles/qualified.csv");
        if(!Qualification.is_open())
        {
            cout << "\nError!\n";
        }
        while(getline(Qualification, aux))
        {
            istringstream input(aux);
            getline(input, aux);
            player_qualified.push_back(stoi(aux));
        }
        Qualification.close();

        //display the finalists
        cout << "\n\nThe players that are going to the grand final are: \n";

        for(i = 0; i < player_qualified.size(); i++)
        {
            cout << " "<< list_of_competitors[player_qualified[i]-1].number << " "
                 << list_of_competitors[player_qualified[i]-1].first_name << " "
                 << list_of_competitors[player_qualified[i]-1].last_name << "\n";
        }
    }


    void genken()
    {
        vector<int> player_number;

        int i,j;

        string aux, err;


        const int rock = 1;
        const int paper = 2;
        const int scrissors = 3;
        int choice1 = 0;
        int choice2 = 0;

        try
        {
            ifstream QualifiedPlayers;
            QualifiedPlayers.open("games/Marbles/qualified.csv");
            if(!QualifiedPlayers.is_open())
            {
                err = "\nThe file cannot be opened!\n";
                throw err;
            }
            while(getline(QualifiedPlayers, aux))
            {
                istringstream input(aux);
                getline(input, aux, ',');
                player_number.push_back(stoi(aux));
            }
            QualifiedPlayers.close();
        }
        catch(string err)
        {
            cout << err;
            throw;
        }

        ofstream Sorted;
        Sorted.open("games/Genken/sorted.csv");
        sort(player_number.begin(),player_number.end(),greater<int>());
        for(auto i: player_number)
        {
            Sorted << i << "\n";
        }
        //Time to play Genken
        //We create a file where we place the winner of every round of genken
        //till the end of the remaining players list
        //choice 1 and choice 2 are the choice of the players
        //mainly choice1 is the choice of the first player at the begining of the game
        //and the choice of the qualified into the next battle player.
        //if we have a winner by choice1 , we swap the next player with actual player
        //and we are going to that till the choice1 is not the winner choice anymore
        //if the choice2, everything remains the same and the choice2 player is going to
        //fight with the next player
        //on every round we increase the m - which is the second player of the game
        //and k - which is the first player of the game(or the qualified player from
        //the past round)
        //when the list of players ends, the last player of the Tournament file
        //is considered the winner and is being printed on the screen.

        ofstream Tournament;
        Tournament.open("games/Genken/tournament.csv");

        int k = 0;
        int m = 1;
        int total = 13;
        while(m != total)
        {
            for(j = k; j < m; j++)
            {
                choice1 = rand() % 3 + 1;
                choice2 = rand() % 3 + 1;
                if(choice1 == rock && choice2 == paper)
                {
                    //paper wins
                    Tournament << player_number[j+1] << "\n";
                    k = k + 1;
                }
                else
                {
                    if(choice1 == paper && choice2 == scrissors)
                    {
                        //scrissors wins
                        Tournament << player_number[j+1] << "\n";
                        k = k + 1;
                    }
                    else
                    {
                        if(choice1 == scrissors && choice2 == rock)
                        {
                            //rock wins
                            Tournament << player_number[j+1] << "\n";
                            k = k + 1;
                        }
                        else
                        {
                            if(choice1 == rock && choice2 == scrissors)
                            {
                                //rock wins
                                Tournament << player_number[j] << "\n";
                                swapping(player_number[j],player_number[j+1]);
                                k = k + 1;
                            }
                            else
                            {
                                if(choice1 == paper && choice2 == rock)
                                {
                                    //paper wins
                                    Tournament << player_number[j] << "\n";
                                    swapping(player_number[j],player_number[j+1]);
                                    k = k + 1;
                                }
                                else
                                {
                                    if(choice1 == scrissors && choice2 == paper)
                                    {
                                        //scrissors wins;
                                        Tournament << player_number[j] << "\n";
                                        swapping(player_number[j],player_number[j+1]);
                                        k = k + 1;
                                    }
                                    else
                                    {
                                        //tie
                                        m = m - 1;
                                    }
                                }
                            }
                        }
                    }
                }
                m = m + 1;
            }
        }
        Tournament.close();
        //read the tournament file, and print the winner, wich is the last number standing
        //in the file.

        vector<int> winner;
        ifstream TournamentWinner;
        TournamentWinner.open("games/Genken/tournament.csv");
        if(!TournamentWinner.is_open())
        {
            cout << "\nThe file cannot be opened!\n";
        }
        while(getline(TournamentWinner, aux))
        {
            istringstream input(aux);
            getline(input, aux, ',');
            winner.push_back(stoi(aux));
        }
        TournamentWinner.close();

        //display the winner on the screen
        int counter = 0;
        cout << "\n\nAnd the winner of the squid game is : ";
        comp_scheme();

        cout << " " << list_of_competitors[winner.back() - 1].first_name << " "
             << list_of_competitors[winner.back() - 1].last_name << "\n";

        for(i = 0; i < list_of_competitors.size(); i++)
        {
            //convert to int
            stringstream geek(list_of_competitors[i].debt);
            int x = 0;
            geek >> x;
            counter += x;
        }
        //convert to int
        stringstream peek(list_of_competitors[winner.back() - 1].debt);
        int y = 0;
        peek >> y;
        cout << "\nThe amount earned by him is: " << counter - y << " $\n";
    }

    /*And the last method from the class final display is the method were we
    display the last characteristics of the game : The top winnings by every
    supervisor and their respective amount of money, and the team that earned
    the most money during the game.
    For that to happen, I read from the past file called "final_teams" were
    I put the supervisor distribution for each player, and i also
    created 9 counters for each supervisor, all of them meant to count
    the amount of money for every eliminated player that belongs
    to them and for the supervisor that had the victorious player I've added the
    winner's debt multiplied by 10
    For the top team by earnings  I created 3 sums that I used to count all
    the earnings and after all the sums are calculated I displayed the team
    with the highest winnings */
    void final_display()
    {
        superv_scheme();
        string aux;
        string err;
        vector<string> p;
        vector<string> player_debt;
        vector<string> supervisor_number;
        vector<string> supervisor_debt;

        //iterator and counters
        int i;
        int counter1 = 0, counter2 = 0, counter3 = 0, counter4 = 0;
        int counter5 = 0, counter6 = 0, counter7 = 0, counter8 = 0;
        int counter9 = 0;
        int index;
        int debt;

        //reading the distribution file into some vectors
        try
        {
            ifstream MyRandomiser;
            MyRandomiser.open("users/teams/final_teams.csv");
            if(!MyRandomiser.is_open())
            {
                err = "\nThe file cannot be opened!\n";
                throw err;
            }
            while(getline(MyRandomiser, aux))
            {
                istringstream input(aux);
                getline(input, aux, ',');
                p.push_back(aux);
                getline(input, aux, ',');
                player_debt.push_back(aux);
                getline(input, aux, ',');
                supervisor_debt.push_back(aux);
                getline(input, aux, ',');
                supervisor_number.push_back(aux);
            }
            MyRandomiser.close();
        }

        catch(string err)
        {
            cout << err;
            throw;
        }

        //reading the winner file so we can have acces to the winner number
        vector<int> winner;
        ifstream TournamentWinner;
        TournamentWinner.open("games/Genken/tournament.csv");
        if(!TournamentWinner.is_open())
        {
            cout << "\nThe file cannot be opened!\n";
        }
        while(getline(TournamentWinner, aux))
        {
            istringstream input(aux);
            getline(input, aux, ',');
            winner.push_back(stoi(aux));
        }
        TournamentWinner.close();
        //for each id_code of the supervisor I assigned a counter
        for(i = 0; i < 100; i++)
        {

            stringstream geek(supervisor_number[i]);
            int x = 0;
            geek >> x;
            stringstream peek(player_debt[i]);
            int y = 0;
            peek >> y;
            //if the supervisor number is matched add to its count the debt of
            //the respective player
            if(x == 101)
            {
                counter1 += y;
            }
            else if(x == 102)
                counter2 += y;
            else if(x == 103)
                counter3 += y;
            else if(x == 104)
                counter4 += y;
            else if(x == 105)
                counter5 += y;
            else if(x == 106)
                counter6 += y;
            else if(x == 107)
                counter7 += y;
            else if(x == 108)
                counter8 += y;
            else if(x == 109)
                counter9 += y;
        }
        //2 variables index and debt that we are going to use to recognize the
        //winner characteristics

        for(i = 0; i < player_debt.size(); ++i)
        {
            stringstream geek(supervisor_number[i]);
            int x = 0;
            geek >> x;
            stringstream peek(player_debt[i]);
            int y = 0;
            peek >> y;

            stringstream convertor(p[i]);
            int z = 0;
            convertor >> z;
            //store the winner's supervisor number into the index
            //and the debt of the winner in the debt variable
            if(z == winner.back())
            {
                index = x;
                debt = y;
            }
            //if the index match the number of the supervisor then the player
            //belongs to the supervisor and the supervisor has a bonus of the
            //winning participant
            if(index == 101)
            {
                counter1 += debt * 10;
            }
            else if (index == 102)
                counter2 += debt * 10;
            else if(index == 103)
                counter3 += debt * 10;
            else if(index == 104)
                counter4 += debt * 10;
            else if(index == 105)
                counter5 += debt * 10;
            else if (index == 106)
                counter6 += debt * 10;
            else if(index == 107)
                counter7 += debt * 10;
            else if(index == 108)
                counter8 += debt * 10;
            else if(index == 109)
                counter9 += debt * 10;
        }//push the final counts into the vector
        vector<int> final_counts;
        final_counts.push_back(counter1);
        final_counts.push_back(counter2);
        final_counts.push_back(counter3);
        final_counts.push_back(counter4);
        final_counts.push_back(counter5);
        final_counts.push_back(counter6);
        final_counts.push_back(counter7);
        final_counts.push_back(counter8);
        final_counts.push_back(counter9);

        //create a file were we are going to store the informations
        ofstream TotalMoney;
        TotalMoney.open("users/supervisors/total_money.csv");
        //put the final earnings into a file;
        for(i = 0; i < final_counts.size(); i++)
        {
            stringstream geek(supervisor_debt[i]);
            int x = 0;
            geek >> x;
            TotalMoney << list_of_supervisors[i].id_code << "," <<final_counts[i] - x << "\n";
        }
        TotalMoney.close();


        //actualise the vector with the amount of money earned by each supervisor by removing their debts
        for(i = 0; i < final_counts.size(); i++)
        {
            stringstream geek(supervisor_debt[i]);
            int x = 0;
            geek >> x;
            final_counts[i] = final_counts[i] - x;

        }
        //As the rules says, we are going to sort the supervisors descending
        //by their winnings.
        //We put each element of the vectors in two "connected" arrays
        //both of them are going to be sorted due to the supervisor winnings
        //so we know what's the supervisor number after the sorting
        //The sorting is realised grace to bubble sort algorithm :D
        int dim = final_counts.size();
        int arr[dim];
        for(i = 0; i < dim; i++)
        {
            arr[i] = final_counts[i];
        }
        int superdim = list_of_supervisors.size();
        int supervisor[superdim];
        for(i = 0; i < list_of_supervisors.size(); i++)
        {
            stringstream geek(list_of_supervisors[i].id_code);
            int x = 0;
            geek >> x;
            supervisor[i] = x;
        }
        //The sort:
        int j;
        for(i = 0; i < dim - 1; i++)
        {
            for(j = 0; j < dim - i - 1; j++)
            {
                if(arr[j] < arr[j + 1])
                {
                    swapping(arr[j], arr[j + 1]);
                    swapping(supervisor[j], supervisor[j + 1]);
                }
            }
        }
        //Display the top money winners in terms of supervisors:
        cout << "\n The top : \n";
        for(i = 0; i < dim; ++i)
        {
            cout << "\n[" << i+1 << "] " << list_of_supervisors[supervisor[i] - 101].s_first_name
            << " " << list_of_supervisors[supervisor[i] - 101].s_last_name << " "
            << arr[i] << " \n";
        }

        vector<int> code;
        vector<string> team;
        ifstream TeamsBudget;
        TeamsBudget.open("users/teams/teams.csv");
        if(!TeamsBudget.is_open())
        {
            cout << "\nThe file cannot be opened!\n";
        }
        while(getline(TeamsBudget, aux))
        {
            istringstream input(aux);
            getline(input, aux, ',');
            code.push_back(stoi(aux));
            getline(input, aux, ',');
            team.push_back(aux);
        }
        TeamsBudget.close();

        cout << "\n\nThe most rich team is : ";

        //3 sums where we store the amount of money for each team
        int sum1 = 0;
        int sum2 = 0;
        int sum3 = 0;
        int var;

        //For this one we are searching for supervisors that have the team tag
        //in their file.
        //Once we found that we are storing their id_code into a variable and use
        //that variable to find the position of the supervisor in the sorted
        //array.
        //After we found the position we stop searching and we add to each sum
        //the amount of money winned by the player stored in that variable;
        //And we keep doing that till the lists ends.
        for(i = 0; i < code.size(); i++)
            {
                if(team[i] == "G1")
                {
                        var = code[i];
                    for(j = 0; j < superdim; j++)
                    {
                        if(supervisor[j] == var)
                        {
                            break;
                        }
                    }
                    sum1 += arr[j];
                }
                if(team[i] == "G2")
                {
                        var = code[i];
                    for(j = 0; j < superdim; j++)
                    {
                        if(supervisor[j] == var)
                        {
                            break;
                        }
                    }
                    sum2 += arr[j];
                }
                if(team[i] == "G3")
                {
                        var = code[i];
                    for(j = 0; j < superdim; j++)
                    {
                        if(supervisor[j] == var)
                        {
                            break;
                        }
                    }
                    sum3 += arr[j];
                }
            }
            //After the final counts we compare each sum to find out which of
            //them it is bigger, and once we find that we display the sum.
            if(sum1 > sum2 && sum1 > sum3)
                cout << " Team 1\n";
                else if(sum2 > sum1 && sum2 > sum3)
                    cout << " Team 2\n";
                else if(sum3 > sum1 && sum3 > sum2)
                    cout << " Team 3\n";

    }
};

//Lets add some design to our program
class CopyRight
{
public:
    void intro()
    {
        cout << "(DMS) Sports";
    }
};
class Menu : public CopyRight
{
public:
    void intro2()
    {
        cout << "\n<---------------------- O /\\ [] -- SQUID GAME -- [] /\\ O ----------------------> \n\n";
    }
    void games(int x)
    {
        cout << "\n< --------------------------------- Game " << x << " ---------------------------------- >\n";
    }
    void games(string x)
    {
        cout << "\n " << x ;
    }
    void games(int x, string y)
    {
        cout << "\nWhat a game that was!!! Lets move to the round " << x << " where we play " << y;
    }
};

class VIP
{
public:
    int player;
    string vip;
    string reaction;
    VIP(string vp, string rc, int pl);
    VIP(int pl, string vp);
    VIP(string vp);
    VIP()
    {
        player = 15;
        vip = "'s";
        reaction = "Wow!";
    }
    ~VIP();
};
VIP::VIP(string vp, string rc, int pl)
{
    vip = vp;
    reaction = rc;
    player = pl;
}
VIP::VIP(int p1, string vp)
{
    player = p1;
    vp = "4 : {panthera mask}";
}
VIP::VIP(string vp)
{
    vp = "1 : {lion mask}";
}
VIP::~VIP(void)
{
}

void vip_noise()
{
    VIP vip1("{bull mask}","Unbelievable", rand() % 99 + 1);
    VIP vip2(rand() % 99 + 1, "looked so tasty during the game :P !!!");
    VIP vip3;

    cout << "VIP : " << vip1.vip << " says :  " << vip1.reaction << " moves from player " << vip1.player << "\n";
}

int main ()
{
    CopyRight Credits;
    Menu menu;
    menu.intro();
    menu.intro2();
    //vip_noise();

    Menu speaker;
      speaker.games(1);
    speaker.games("\t\t\t      Green Light Red Light\n");
    TheFrontMan TFM;
    TheFrontMan game1;
    TheFrontMan game2;
    TheFrontMan game3;
    TheFrontMan game4;
    TheFrontMan presentation;

    TFM.comp_scheme();
    TFM.superv_scheme();
    TFM.team_tactic();
    game1.red_light_green();
    speaker.games(2, "Tug Of War\n");
    speaker.games(2);
    speaker.games("\t\t\t\t   Tug Of War\n");
    game2.tug_of_war();
    vip_noise();
    speaker.games(3, "Marbles\n");
    speaker.games(3);
    speaker.games("\t\t\t\t   Marbles\n");
    game3.marbles();
    speaker.games(4, "Genken\n");

    speaker.games(4);
    speaker.games("\t\t\t\t   Genken\n");
    game4.genken();
    presentation.final_display();



    return 0;

}

